# Git详解

[TOC]

## 一、起步

### 1.1 基础

#### 直接记录快照，而非差异比较

> Git 并不保存版本前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照 的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。
> ![Git版本控制方式](http://static.open-open.com/lib/uploadImg/20120201/20120201121204_39.png)

#### 近乎所有操作都是本地执行

> 在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。但如果用 CVCS 的话，差不多所有操作都需要连接网络。因为 Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快。

#### 时刻保持数据完整性

> 在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。换句话说，不可能在你修改了文件或目录之后，Git 一无所知。这项特性作为 Git 的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，Git 都能立即察觉。
>
> Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串。该字串由 40 个十六进制字符（0-9 及 a-f）组成，看起来就像是：
>
> ```
> 24b9da6552252987aa493b52f8696cd6d3b00373
> ```
>
> Git 的工作完全依赖于这类指纹字串，所以你会经常看到这样的哈希值。实际上，所有保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。

#### 多数操作仅添加数据

> 常用的 Git 操作大多仅仅是把数据添加到数据库。因为任何一种不可逆的操作，比如删除数据，都会使回退或重现历史版本变得困难重重。

#### 文件的三种状态

> 对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库 中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。
>
> ![三种状态的交互](http://static.open-open.com/lib/uploadImg/20120201/20120201121205_151.png)
>
> 1. 在工作目录中修改某些文件。 2. 对修改后的文件进行快照，然后保存到暂存区域。 3. 提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。

每个项目都有一个 Git 目录（译注：如果 `git clone` 出来的话，就是其中 `.git` 的目录；如果`git clone --bare` 的话，新建的目录本身就是 Git 目录。），它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。

### 1.2 配置方式

```
系统全局(/etc/gitconfig) $ git config --system
当前用户(~/.gitconfig) $ git config --global
当前项目(.git/config) $ git config
```

#### 用户信息

```
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
```

#### 文本编辑器

```
$ git config --global core.editor emacs
```

#### 差异分析工具

```
$ git config --global merge.tool vimdiff
```

#### 查看配置信息

```
$ git config --list
```

> 有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 `/etc/gitconfig` 和 `~/.gitconfig`），不过最终 Git 实际采用的是最后一个。

**查看单个配置**

```
$ git config user.name
```



---



## 二、基础

### 2.1 初始化

#### 2.1.1 从本地初始化新仓库

```
$ git init
```

> 初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。不过目前，仅仅是按照既有的结构框架初始化好了里边所有的文件和目录，但我们还没有开始跟踪管理项目中的任何一个文件。

#### 2.1.2 从现有仓库克隆

```
$ git clone [url] [新的目录名-可选]
$ git clone git://github.com/schacon/grit.git mygrit
```

> 如果想对某个开源项目出一份力，可以先把该项目的 Git 仓库复制一份出来，这就需要用到 git clone 命令。如果你熟悉其他的 VCS 比如 Subversion，你可能已经注意到这里使用的是 clone 而不是 checkout。这是个非常重要的差别，Git 收取的是项目历史的所有数据（每一个文件的每一个版本），服务器上有的数据克隆之后本地也都有了。实际上，即便服务器的磁盘发生故障，用任何一个克隆出来 的客户端都可以重建服务器上的仓库，回到当初克隆时的状态（虽然可能会丢失某些服务器端的挂钩设置，但所有版本的数据仍旧还在，有关细节请参考第四章）。

### 2.2 记录每次更新到仓库

> 请记住，工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记 录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存 区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。
>
> 在编辑过某些文件之后，Git 将这些文件标为已修改。我们逐步把这些修改过的文件放到暂存区域，直到最后一次性提交所有这些暂存起来的文件，如此重复。

![文件的状态变化周期](http://static.open-open.com/lib/uploadImg/20120201/20120201121432_845.png)

#### 检查当前文件状态

```
$ git status
```

该命令可以显示出当前使用的分支，未跟踪、已修改未暂存、已暂存未提交的文件

#### 跟踪新文件

```
$ git add [文件文]
```

> 在 `git add` 后面可以指明要跟踪的文件或目录路径。如果是目录的话，就说明要递归跟踪该目录下的所有文件。（译注：其实`git add` 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area，同时未曾跟踪过的文件标记为需要跟踪。这样就好理解后续 add 操作的实际意义了。）

#### 暂存已修改文件

```
$ git add [文件文]
```

> 这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等

#### 忽略某些文件

我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。

```
$ cat .gitignore
# 此为注释 – 将被 Git 忽略
*.a       # 忽略所有 .a 结尾的文件
!lib.a    # 但 lib.a 除外
/TODO     # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
build/    # 忽略 build/ 目录下的所有文件
doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
```

*要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。*

**文件 .gitignore 的格式规范如下：**

- 所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。
- 可以使用标准的 glob 模式匹配。 * 匹配模式最后跟反斜杠（`/`）说明要忽略的是目录。 * 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（`!`）取反。
> 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（`*`）匹配零个或多个任意字符；`[abc]` 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（`?`）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如`[0-9]` 表示匹配所有 0 到 9 的数字）。

#### 查看已暂存和未暂存的更新

```
$ git diff #比较工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。
$ git diff --cached #比较已经暂存起来的文件和上次提交时的快照之间的差异
$ git diff --staged #效果同上，更好记些，1.6.1及更高版本可以使用
```

#### 提交更新

```
$ git commit #这种方式会启动文本编辑器以便输入本次提交的说明
$ git commit -m "提交说明"
$ git commit -a #会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤
```

例：

>```
>$ git commit -m "Story 182: Fix benchmarks for speed"
>[master]: created 463dc4f: "Fix benchmarks for speed"
> 2 files changed, 3 insertions(+), 0 deletions(-)
> create mode 100644 README
>```
>
>可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（`463dc4f`），以及在本次提交中，有多少文件修订过，多少行添改和删改过。

#### 移除文件

```
$ git rm [文件路径]#移除跟踪并删除文件(在暂存区及工作目录移除)
#文件路径可以使用 glob 模式，如log/\*.log，注意*得用\*才不会被shell展开。
$ git rm --cached [文件路径]#移除跟踪但不删除文件(即只在暂存区移除)
```

#### 移动文件

```
$ git mv [file_from] [file_to]
```

等价于

```
$ mv [file_from] [file_to]
$ git rm [file_from]
$ git add [file_to]
```

### 2.3 查看提交历史

```
$ git log
```
筛选参数：

```
选项 说明
-(n)	仅显示最近的 n 条提交
--since, --after 仅显示指定时间之后的提交。
--until, --before 仅显示指定时间之前的提交。
--author 仅显示指定作者相关的提交。
--committer 仅显示指定提交者相关的提交。
--grep 搜索提交说明中的关键字
--no-merges 仅显示未合并的
-- [指定搜索路径] 必须放在其他参数的最后，注意--后面有一个空格
#请注意，如果要得到同时满足这些选项搜索条件的提交，就必须用--all-match 选项。
```

显示参数：

```
-p 按补丁格式显示每个更新之间的差异。
--stat 显示每次更新的文件修改统计信息。
--shortstat 只显示 --stat 中最后的行数修改添加移除统计。
--name-only 仅在提交信息后显示已修改的文件清单。
--name-status 显示新增、修改、删除的文件清单。
--abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。
--relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。
--graph 显示 ASCII 图形表示的分支合并历史。
--pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。
```

```
--pretty=oneline 每个提交放在一行显示
--pretty=format 可以定制要显示的记录格式，占位符如下:
选项	 说明
%H	提交对象（commit）的完整哈希字串
%h	提交对象的简短哈希字串
%T	树对象（tree）的完整哈希字串
%t	树对象的简短哈希字串
%P	父对象（parent）的完整哈希字串
%p	父对象的简短哈希字串
%an	作者（author）的名字
%ae	作者的电子邮件地址
%ad	作者修订日期（可以用 -date= 选项定制格式）
%ar	作者修订日期，按多久以前的方式显示
%cn	提交者(committer)的名字
%ce	提交者的电子邮件地址
%cd	提交日期
%cr	提交日期，按多久以前的方式显示
%s	提交说明
```

> 用 oneline 或 format 时结合 `--graph` 选项，可以看到开头多出一些 ASCII 字符串表示的简单图形，形象地展示了每个提交所在的分支及其分化衍合情况。
>
> 如：
>
> ```
> $ git log --pretty=format:"%h %s" --graph
> * 2d3acf9 ignore errors from SIGCHLD on trap
> *  5e3ee11 Merge branch 'master' of git://github.com/dustin/grit
> |\
> | * 420eac9 Added a method for getting the current branch.
> * | 30e367c timeout code and tests
> * | 5a09431 add timeout protection to grit
> * | e1193f8 support for heads with slashes in them
> |/
> * d6016bc require time for xmlschema
> *  11d191e Merge branch 'defunkt' into local
> ```

### 2.4 撤消操作

#### 修改最后一次提交

```
$ git commit --amend #修正最后一次提交，即该次提交与上一次提交当成一次提交
```

#### 取消已经暂存的文件

```
$ git reset HEAD [文件路径]
```

#### 取消对文件的修改

```
$ git checkout -- [文件路径] #将暂存区的文件拷过来覆盖原始文件，达到取消修改的目的
```

*注意之前的没提交没暂存的修改会完全丢失，找不回来，使用时需谨慎*

### 2.5 远程仓库的使用

#### 查看当前的远程库

```
$ git remote #查看所有远程仓库
$ git remote -v #--verbose的简写,显示对应的克隆地址
$ git remote show [远程仓库别名] #查看某个远程仓库的显示信息，包括默认的push、pull分支
```

#### 添加远程仓库

```
$ git remote add [远程仓库别名] [url] #添加一个远程仓库，只是添加引用，不做数据操作
$ git fetch [远程仓库别名] #到远程仓库中拉取所有你本地仓库中还没有的数据
```

*fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。*

#### 推送数据到远程仓库

```
$ git push [远程仓库别名] [分支名]
```

*如果在你推数据前，已经有其他人推送了若干更新，那 你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。*

#### 远程仓库的删除和重命名

```
$ git remote rename [旧名] [新名] #重合名
$ git remote rm [远程仓库别名] #删除
```

### 2.6 打标签

> Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特 定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标 签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。

#### 显示已有的标签

```
$ git tag #显示所有标签
$ git tag -l 'v1.4.2.*' #显示匹配v.14.2.*名字的标签
$ git show [标签名字] #查看相应标签的版本信息，并连同显示打标签时的提交对象
```

#### 含附注的标签

```
$ git tag -a [标签名字] -m '标签说明' #创建附注标签
```

#### 签署标签

> 如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 `-a` 改为 `-s` （译注： 取 `signed` 的首字母）即可：

```
$ git tag -s [标签名字] -m '标签说明' #创建签署附注标签
```

#### 轻量级标签

> 轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 `-a`，`-s` 或 `-m` 选项都不用，直接给出标签名字即可：

```
$ git tag [标签名字] #创建轻量级标签
```

#### 验证标签

> 可以使用 `git tag -v [tag-name]` （译注：取 `verify` 的首字母）的方式验证已经签署的标签。此命令会调用 GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证：

```
$ git tag -v [标签名字] #验证签署标签
```

#### 后期加注标签

```
$ git tag -a [标签名字] [提交对象的校验和（或前几位字符] #对指定的提交版本添加标签
例：
$ git tag -a v1.2 9fceb02
```

#### 分享标签

> 默认情况下，`git push` 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行`git push origin [tagname]` 即可

```
$ git push [远程仓库别名] [标签名字] #推送指定标签
$ git push [远程仓库别名] --tags #推送所有标签
```

### 2.7  技巧和窍门

#### 自动完成

> 如果你用的是 Bash shell，可以试试看 Git 提供的自动完成脚本。下载 Git 的源代码，进入 `contrib/completion` 目录，会看到一个`git-completion.bash` 文件。将此文件复制到你自己的用户主目录中（译注：按照下面的示例，还应改名加上点：`cp git-completion.bash ~/.git-completion.bash`），并把下面一行内容添加到你的`.bashrc` 文件中：
> ```
> source ~/.git-completion.bash
> ```
> 也可以为系统上所有用户都设置默认使用此脚本。Mac 上将此脚本复制到 `/opt/local/etc/bash_completion.d` 目录中，Linux 上则复制到`/etc/bash_completion.d/` 目录中。这两处目录中的脚本，都会在 Bash 启动时自动加载。
> 如果在 Windows 上安装了 msysGit，默认使用的 Git Bash 就已经配好了这个自动完成脚本，可以直接使用。
>
> 在输入 Git 命令的时候可以敲两次跳格键（Tab），就会看到列出所有匹配的可用命令建议：
> ```
> $ git co
> commit config
> ```
>
> 此例中，键入 git co 然后连按两次 Tab 键，会看到两个相关的建议（命令） commit 和 config。继而输入 `m `会自动完成`git commit` 命令的输入。
>
> 命令的选项也可以用这种方式自动完成，其实这种情况更实用些。比如运行 `git log` 的时候忘了相关选项的名字，可以输入开头的几个字母，然后敲 Tab 键看看有哪些匹配的：
>
> ```
> $ git log --s
> --shortstat  --since=  --src-prefix=  --stat   --summary
> ```
>
> 这个技巧不错吧，可以节省很多输入和查阅文档的时间。

#### Git 命令别名

Git 并不会推断你输入的几个字符将会是哪条命令，不过如果想偷懒，少敲几个命令的字符，可以用 `git config` 为命令设置别名。来看看下面的例子：

```
$ git config --global alias.[别名] [原始命令名]
例：
$ git config --global alias.ci commit #设置后如果要输入 git commit 只需键入 git ci 即可
$ git config --global alias.unstage 'reset HEAD --'设置后输入git unstage就可以取消暂存文件
$ git config --global alias.last 'log -1 HEAD' #设置后输入git last就可以查看最后一次的提交信息
```

实际上 Git 只是简单地在命令中替换了你设置的别名。不过有时候我们希望运行某个外部命令，而非 Git 的附属工具，这个好办，只需要在命令前加上 `!` 就行。如果你自己写了些处理 Git 仓库信息的脚本的话，就可以用这种技术包装起来。作为演示，我们可以设置用 `git visual`启动`gitk`：

```
$ git config --global alias.visual "!gitk"
```